{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 요약\n본 서비스는 사용자가 실시간으로 픽셀을 배치해 거대한 디지털 캔버스를 공동 제작하는 웹 기반 협업 아트 프로젝트다. r/place와 유사하나 한국어 UX, 유연한 쿨다운, 커뮤니티 기능 등 차별화를 통해 창작·소통·게임성을 동시에 제공한다.\n\n## 2. 문제 정의\n- 온라인 공동 창작 플랫폼 부족으로 이용자들은 대규모 협업 그림 경험을 얻기 어렵다.  \n- 기존 서비스는 일회성 이벤트로 끝나 지속적 커뮤니티 및 데이터 보존 기능이 약하다.  \n- 무분별한 픽셀 스팸, 악성 사용자, 성인/정치 콘텐츠 등 관리 문제 존재.\n\n## 3. 목표 및 지표\n- 1차 목표: 실시간 픽셀 공동 그림 플랫폼 MVP 출시  \n- 부차 목표: 커뮤니티 확장, 타임랩스·모바일 최적화, 관리자 툴 제공  \n- 성공 지표  \n  - DAU 10,000명, 1인당 평균 픽셀 20개/일  \n  - 쿨다운 위반율 < 2%  \n  - 서버 응답 200ms 이하, 99.9% 가용성  \n  - 초기 3개월 리텐션 25% 이상  \n\n## 4. 타깃 사용자\n### 주요 사용자\n- 15~35세 디지털 네이티브, 커뮤니티 참여·밈 문화 선호  \n- 웹툰·게임·서브컬처 팬덤, 실시간 상호작용 콘텐츠 소비자  \n### 이해관계자\n- 브랜드/커뮤니티 운영자(이벤트 협업)  \n- 스트리머·인플루언서(콘텐츠 제작)  \n- 운영팀, 마케터, 관리자  \n\n## 5. 사용자 스토리\n- “창작자로서 실시간으로 픽셀을 찍어 공동 아트를 완성하고 싶다.”  \n- “관전자/시청자로서 다른 사람이 그리는 과정을 실시간으로 보고 싶다.”  \n- “운영자로서 악성 사용자를 빠르게 제재하고 싶다.”  \n- “모바일 사용자로서 화면을 확대·이동하며 편히 그리기를 원한다.”  \n- “커뮤니티 리더로서 길드를 만들어 특정 로고를 그리기 원한다.”  \n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 픽셀 캔버스  \n   - 고정 2000×2000 그리드(값 조정 가능).  \n   - 수용량: 최대 4,000,000 픽셀.  \n   - AC: 좌표·색상 DB 반영 즉시 모든 클라이언트에 전송됨.  \n2. 픽셀 그리기/색 변경  \n   - 팔레트 32색; 이후 확장 가능.  \n   - AC: 클릭 시 서버에 POST /pixel; 성공 후 쿨다운 시작.  \n3. 실시간 동기화  \n   - WebSocket 채널 ‘/canvas’ 사용.  \n   - AC: 1000명 동시 접속 시 지연 < 300ms.  \n4. 쿨다운 시스템  \n   - 기본 5초, 로그인 사용자는 3초(변경 가능).  \n   - AC: 남은 시간 UI 표시, 남용 시 1분 페널티.  \n5. 기본 UI  \n   - React + Redux; 좌측 팔레트, 중앙 캔버스, 우측 타이머.  \n   - 단축키(마우스 휠 확대, 스페이스 이동).  \n6. 백엔드 API  \n   - Spring Boot REST + WebSocket; Redis pub/sub.  \n   - AC: 트랜잭션 처리 50ms 내.  \n7. 영속성  \n   - MySQL에 전체 캔버스 스냅샷 1분 주기 저장.  \n   - Redis에 임시 캔버스 상태, TTL 24h.\n\n### 부가 기능 (Nice-to-have)\n- OAuth2 로그인, 프로필·픽셀 통계  \n- 모바일 반응형 및 PWA  \n- 영역 북마크, 미니맵  \n- 타임랩스 자동 생성·다운로드  \n- 채팅, 길드, 랭킹  \n- 주기적 캔버스 리셋/아카이브  \n- 관리자 대시보드(밴, 롤백, 백업)  \n- 고급 쿨다운(IP, 계정 레벨, 머신러닝 패턴 탐지)\n\n## 7. 비기능 요구사항\n- 성능: TPS 10,000, 동시 5,000, 지연 200ms 이하  \n- 보안: JWT, HTTPS, WAF, XSS/CSRF 차단  \n- 사용성: 최초 러닝커브 3분 내, 접근성 KWCAG 2.1 AA  \n- 확장성: 멀티캔버스 샤딩 구조, 오토스케일  \n- 호환성: 최신 크롬·사파리·엣지·모바일 브라우저 지원  \n\n## 8. 기술 고려사항\n- 아키텍처: React SPA → Nginx → Spring Boot → Redis → MySQL(AWS RDS)  \n- 인프라: AWS ECS/Fargate, S3 정적 콘텐츠, CloudFront CDN  \n- 데이터: 픽셀 테이블(좌표, 색상, modified_at), 사용자·길드·로그 테이블  \n- 외부 연동: OAuth(Google/Kakao), Sentry(모니터링), Slack 알림  \n- 배포: GitHub Actions, Blue/Green  \n\n## 9. 성과 지표\n- 사용자: DAU/MAU, 신규 가입, 평균 세션 10분 이상  \n- 비즈니스: 스폰서 이벤트당 노출 1M, 광고 CTR 2%  \n- 기술: WebSocket 오류율 <0.1%, 빌드 실패율 <2%  \n\n## 10. 일정\n| 단계 | 기간 | 주요 산출물 |\n| --- | --- | --- |\n| 1. 기획·설계 | 2주 | PRD, 와이어프레임, ERD |\n| 2. MVP 개발 | 6주 | 핵심 기능 1~7, 베타 배포 |\n| 3. 베타 테스트 | 2주 | 부하·UX 개선, 버그 수정 |\n| 4. 정식 출시 | 2주 | 마케팅, 운영 가이드 |\n| 5. 확장 기능 | 8주 | 로그인, 모바일, 타임랩스, 채팅 |\n\n## 11. 위험 및 대응\n- 서버 부하 폭주 → 오토스케일, 캐시 분산  \n- 악성 그림/정치 선동 → 키워드 필터, 관리자 실시간 모니터링  \n- 봇 공격 → reCAPTCHA, 속도제한, IP 블록  \n- 저조한 참여 → 인플루언서 협업, 이벤트 보상  \n\n## 12. 향후 계획\n- AI 이미지 추천·색상 자동 완성  \n- NFT 마켓 연동(저작권 검토 후)  \n- 기업 브랜드 캠페인용 화이트라벨 제공  \n- 다중 캔버스·3D 큐브 캔버스 실험  \n\n(총 문서 길이: 약 5,300자)",
      "writedAt": "2025-07-08T08:21:50.820Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  r/place 형태의 실시간 픽셀 협업 캔버스를 React SPA + Spring Boot 백엔드로 구현한다. Redis in-memory cache와 MySQL RDS를 조합해 실시간성과 영속성을 모두 확보하며, AWS Fargate 기반 컨테이너 오케스트레이션으로 최소 운영 부담과 자동 확장을 달성한다.\n\n- **핵심 기술 스택**  \n  React 18 · Redux Toolkit / Spring Boot 3.x · Java 17 / MySQL 8 / Redis 7 · PubSub / AWS ECS Fargate · S3 · CloudFront / GitHub Actions CI-CD\n\n- **주요 기술 목표**  \n  ‑ WebSocket 지연 ≤ 300 ms (동시 1 k)  \n  ‑ REST API 지연 ≤ 200 ms (p95)  \n  ‑ 99.9 % 가용성, TPS 10 k 버스트 대응  \n  ‑ 배포 후 롤백 ≤ 2 분, 데이터 RPO ≤ 5 분\n\n- **중요 기술 가정**  \n  ‑ 1차 릴리스 동시 사용자 최대 5 k, 추후 수평 확장 전제  \n  ‑ AWS 관리형 서비스 우선 사용, 온프레미스 요구 없음  \n  ‑ 지정 스택(React/Spring/MySQL/Redis) 고정, 변동 없음  \n\n---\n\n## 2. Technology Stack Architecture\n\n### Frontend Technology Stack\n- **코어 프레임워크**: React 18, TypeScript 5\n- **상태 관리**: Redux Toolkit + RTK Query (픽셀‧쿨다운 캐싱)\n- **라우팅**: React Router v6\n- **UI/UX 프레임워크**: MUI v5 + Emotion CSS-in-JS\n- **빌드 도구**: Vite 5 (dev server + HMR) · ESLint + Prettier · Jest + React Testing Library\n\n### Backend Technology Stack\n- **런타임**: OpenJDK 17 (LTS)\n- **웹 프레임워크**: Spring Boot 3 · Spring WebFlux (REST) · Spring WebSocket\n- **API 디자인**: REST (HTTP/JSON) + WebSocket (STOMP over SockJS)\n- **입력 검증**: Hibernate Validator (JSR 380) + DTO 패턴\n- **미들웨어 컴포넌트**: Spring Security (JWT), Micrometer (관측), Logback (로깅)\n\n### Database & Persistence Layer\n- **주 데이터베이스**: MySQL 8 (AWS RDS Multi-AZ) — 관계형 무결성, point-in-time recovery\n- **스키마 설계**: 픽셀(x,y UNIQUE), 사용자, 픽셀 히스토리; 3NF 기본, 고빈도 쓰기 테이블 파티셔닝 미적용(초기 규모 기준)\n- **캐싱**: Redis ElastiCache Cluster 모드, Hash 구조로 canvas:current_state, TTL 쿨다운 Key\n- **데이터 마이그레이션**: Flyway 버전 관리\n- **백업/복구**: RDS 자동 스냅샷(30일), S3 장기 저장; Redis AOF 매 1 분\n\n### Infrastructure & DevOps\n- **호스팅**: AWS — ECS Fargate(백), S3 + CloudFront(정적), ALB(TLS)\n- **컨테이너화**: Docker Compose(로컬) → ECR 이미지 배포\n- **CI/CD**: GitHub Actions — PR 단위 테스트 → main merge 시 Blue/Green 배포\n- **모니터링**: CloudWatch + ECS Container Insights · Sentry (프론트·백)\n- **로깅**: JSON 로그 → CloudWatch Logs → Loki/Grafana (선택)\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- 프론트엔드 SPA  \n  ‑ React UI, WebSocket 클라이언트, JWT 관리\n- API Gateway / ALB  \n  ‑ HTTPS 종단, 경로 기반 라우팅(/api, /ws)\n- Spring Boot 백엔드  \n  ‑ REST API, WebSocket, 쿨다운 로직\n- Redis Cluster  \n  ‑ 실시간 픽셀 Hash, Pub/Sub 브로드캐스트, 쿨다운 TTL\n- MySQL RDS  \n  ‑ 영속 스냅샷, 트랜잭션 보존\n- S3 + CloudFront  \n  ‑ 정적 리소스·타임랩스 파일 서빙\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[React SPA] -- HTTPS --> B(ALB)\n    B --> C[Spring Boot API]\n    C -- JDBC --> D[MySQL RDS]\n    C -- Redis Client --> E[Redis Cluster]\n    E -- Pub/Sub --> C\n    C -- WebSocket --> A\n```\n- React SPA는 ALB를 통해 REST API 및 WebSocket 엔드포인트에 연결한다.  \n- Spring Boot 인스턴스는 Redis에 픽셀 업데이트 후 Pub/Sub으로 다른 인스턴스와 동기화한다.  \n- MySQL은 주기적 배치 또는 비동기 Queue로 Redis 데이터를 영속화한다.  \n- CloudFront는 S3 정적 파일과 /ws 엔드포인트를 제외한 모든 리소스를 캐싱한다.\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**\n- 픽셀, 사용자, 관리자, 공용(shared) 바운디드 컨텍스트 구분\n- Layered 패턴: controller → service → repository → entity  \n- 공용 유틸, 예외, 보안 모듈은 shared 폴더에 통합\n\n**Universal File & Folder Structure**\n```\n/root-monorepo\n├── frontend/\n│   ├── src/\n│   │   ├── domains/\n│   │   │   ├── canvas/\n│   │   │   │   ├── components/\n│   │   │   │   ├── hooks/\n│   │   │   │   └── slice.ts\n│   │   │   └── auth/\n│   │   ├── app/\n│   │   ├── shared/\n│   │   └── index.tsx\n│   └── vite.config.ts\n├── backend/\n│   ├── src/main/java/com/example/\n│   │   ├── canvas/\n│   │   │   ├── controller/\n│   │   │   ├── service/\n│   │   │   ├── domain/\n│   │   │   └── infra/\n│   │   ├── user/\n│   │   ├── admin/\n│   │   └── shared/\n│   └── src/main/resources/\n├── database/\n│   └── migration/ (Flyway .sql)\n└── infrastructure/\n    ├── docker/\n    ├── terraform/ (선택)\n    └── cicd/\n```\n\n### Data Flow & Communication Patterns\n- **클라이언트-서버**: POST /api/pixel → JWT 검증 → 서비스 로직 → 200 응답  \n- **DB 인터랙션**: Spring Data JPA + HikariCP 풀, 트랜잭션 @Transactional  \n- **외부 서비스**: Google OAuth → Spring Security OAuth2, SES 메일 발송  \n- **실시간 통신**: /ws/canvas 채널 STOMP 메시지; 서버 → 클라이언트 브로드캐스트  \n- **데이터 동기화**: Redis Write-Through → Async Scheduler(1 min)로 MySQL flush\n\n---\n\n## 4. Performance & Optimization Strategy\n- Redis Hash + Pipeline으로 초당 10 k 픽셀 쓰기 처리, MySQL 부하 분산  \n- WebSocket 세션당 Δ픽셀만 전송해 네트워크 트래픽 최소화  \n- ALB + CloudFront 캐싱으로 정적 리소스 TTFB 단축  \n- HikariCP 최대 pool size=2×vCPU로 DB 커넥션 효율화\n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP)\n- 인프라: VPC, RDS, Redis, ECS Fargate 클러스터  \n- 핵심 기능: 캔버스 표시·픽셀 그리기·쿨다운·실시간 동기화  \n- 보안: JWT 로그인, HTTPS, 기본 RBAC  \n- 개발 환경: Monorepo, Vite HMR, GitHub Actions CI  \n- 일정: 6 주\n\n### Phase 2: Feature Enhancement\n- 추가 기능: OAuth2, 프로필, 모바일 반응형, 관리자 대시보드  \n- 성능 개선: Redis Cluster Shard, MySQL Read Replica  \n- 보안 강화: WAF, rate-limit, 이미지 필터링 Lambda  \n- 모니터링: Sentry Alert→Slack, Grafana Dashboard  \n- 일정: 8 주\n\n### Phase 3: Scaling & Optimization\n- 확장: 멀티 캔버스 샤딩, WebSocket Server Auto Scaling Policy  \n- 고급 통합: 타임랩스 자동 렌더링 Batch, SNS/SQS Event Queue  \n- 엔터프라이즈: 감사 로그, GDPR 데이터 삭제 API  \n- 컴플라이언스: KISA ISMS 준수 문서화  \n- 일정: 12 주\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **기술 리스크**: Redis 단일 장애 → Cluster 모드 + Multi AZ  \n- **성능 리스크**: WebSocket 과부하 → 세션 분산, idle timeout  \n- **보안 리스크**: JWT 탈취 → 짧은 TTL + Refresh Token Rotate  \n- **통합 리스크**: SES 발송 한도 → 사전 리밋 증설 요청  \n- **완화 전략**: Chaos 테스트, Auto Recovery Script, Canary 배포\n\n### Project Delivery Risks\n- **일정 리스크**: 실시간 로직 난이도 → MVP 범위 고정, 스파이크 테스트  \n- **자원 리스크**: 프론트·백 풀스택 인력 부족 → 모듈별 병렬 개발  \n- **품질 리스크**: 테스트 커버리지 저조 → E2E Cypress, 백엔드 Testcontainers  \n- **배포 리스크**: 잘못된 컨테이너 이미지 → 이미지 서명 + 취소 스위치  \n- **비상 계획**: 기능 플래그, 데이터 스냅샷, 롤백 플레이북\n\n---",
      "writedAt": "2025-07-08T08:21:50.821Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline Document\n\n---\n\n## 1. Project Overview\n\nThis project is a real-time collaborative pixel art platform, architected as a React 18 + TypeScript SPA frontend and a Spring Boot 3.x + Java 17 backend, with MySQL 8 (AWS RDS) for persistence and Redis 7 for in-memory operations and pub/sub. The system is deployed on AWS ECS Fargate, utilizes S3 + CloudFront for static assets, and follows a monorepo structure for unified management. Key architectural decisions include domain-driven organization, layered backend structure, Redux Toolkit for state management, REST + WebSocket APIs, and rigorous CI/CD via GitHub Actions.\n\n---\n\n## 2. Core Principles\n\n1. **Clarity and Explicitness:** All code MUST be self-explanatory and avoid implicit side effects.\n2. **Single Responsibility:** Each module, class, or function MUST have one clear purpose.\n3. **Fail Fast and Safe:** All errors MUST be handled explicitly and logged appropriately.\n4. **Consistency:** Code style, naming, and structure MUST be uniform across the codebase.\n5. **Testability:** All business logic MUST be covered by automated tests.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 Frontend (React 18 + TypeScript 5 + Redux Toolkit)\n\n#### File Organization and Directory Structure\n\n- **MUST:** Follow `/src/domains/{domain}/{components|hooks|slice.ts}` structure.\n- **MUST:** Place shared utilities under `/src/shared`.\n- **MUST NOT:** Place unrelated components or logic in a single file or folder.\n\n```typescript\n// MUST: Canvas domain structure\n/src/domains/canvas/\n  components/\n    Canvas.tsx\n  hooks/\n    useCanvasSync.ts\n  slice.ts\n```\n\n#### Import/Dependency Management\n\n- **MUST:** Use absolute imports from `src/` base.\n- **MUST:** Group external, internal, and style imports separately.\n- **MUST NOT:** Use wildcard (`*`) imports or import unused modules.\n\n```typescript\n// MUST: Import order\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport { Canvas } from 'domains/canvas/components/Canvas';\nimport 'shared/styles/global.css';\n```\n\n#### Error Handling Patterns\n\n- **MUST:** Wrap all async logic (e.g., API calls, WebSocket events) in try/catch.\n- **MUST:** Show user-friendly error UI for all recoverable errors.\n- **MUST:** Log errors to Sentry via a centralized error boundary.\n\n```typescript\n// MUST: Error boundary example\nimport { ErrorBoundary } from 'react-error-boundary';\n\n<ErrorBoundary fallback={<ErrorFallback />}>\n  <App />\n</ErrorBoundary>\n```\n\n---\n\n### 3.2 Backend (Spring Boot 3.x + Java 17)\n\n#### File Organization and Directory Structure\n\n- **MUST:** Use `com.example.{domain}.{layer}` structure.\n- **MUST:** Separate `controller`, `service`, `domain`, and `infra` layers.\n- **MUST:** Place shared utilities and exceptions in `shared`.\n\n```java\n// MUST: Canvas domain structure\ncom.example.canvas.controller.CanvasController\ncom.example.canvas.service.CanvasService\ncom.example.canvas.domain.Pixel\ncom.example.canvas.infra.RedisPixelRepository\n```\n\n#### Import/Dependency Management\n\n- **MUST:** Use explicit imports; avoid wildcard imports.\n- **MUST:** Use dependency injection via constructor for all beans.\n- **MUST NOT:** Inject dependencies via field injection.\n\n```java\n// MUST: Constructor injection\n@Service\npublic class CanvasService {\n    private final PixelRepository pixelRepository;\n\n    public CanvasService(PixelRepository pixelRepository) {\n        this.pixelRepository = pixelRepository;\n    }\n}\n```\n\n#### Error Handling Patterns\n\n- **MUST:** Use `@ControllerAdvice` for global exception handling.\n- **MUST:** Return standardized error responses (e.g., `ErrorResponse` DTO).\n- **MUST:** Log all server errors with contextual information.\n\n```java\n// MUST: Global exception handler\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(PixelNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(PixelNotFoundException ex) {\n        return ResponseEntity.status(HttpStatus.NOT_FOUND)\n            .body(new ErrorResponse(\"PIXEL_NOT_FOUND\", ex.getMessage()));\n    }\n}\n```\n\n---\n\n## 4. Code Style Rules\n\n### 4.1 MUST Follow\n\n1. **TypeScript:** Always use explicit types for function parameters and return values to prevent type inference errors.\n2. **React:** Use functional components and React hooks exclusively for all new code. Avoid class components.\n3. **Redux Toolkit:** Use slices per domain, colocate actions and reducers, and use RTK Query for API state.\n4. **Java:** Use Java 17 features (e.g., records, switch expressions) where appropriate for clarity and brevity.\n5. **Spring Boot:** Use DTOs for all API input/output. Validate input with Hibernate Validator annotations.\n6. **SQL:** Use parameterized queries or JPA methods to prevent SQL injection.\n\n#### Rationale\n\n- Explicit types and DTOs prevent runtime errors and improve maintainability.\n- Functional components and hooks are the modern React standard.\n- Slices and RTK Query enforce modular, maintainable state.\n- Java 17 features reduce boilerplate.\n- Input validation and parameterized queries are essential for security.\n\n```typescript\n// MUST: Explicit typing\nfunction setPixel(x: number, y: number, color: string): SetPixelAction {\n  return { type: 'SET_PIXEL', payload: { x, y, color } };\n}\n```\n\n```java\n// MUST: DTO with validation\npublic record SetPixelRequest(\n    @NotNull @Min(0) Integer x,\n    @NotNull @Min(0) Integer y,\n    @NotNull @Pattern(regexp = \"#[0-9",
      "writedAt": "2025-07-08T08:21:50.821Z"
    }
  ]
}